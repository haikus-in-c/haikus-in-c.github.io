<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <meta charset="utf-8">
  <title>
    
      Home &ndash;
    
    Haikus in C
  </title>

  <meta name="author" content="Haikus in C" />
  <meta name="description" content="a place where two columbia cs students share code and talk about their projects" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <link rel="alternate" type="application/rss+xml" href="/atom.xml" />

  <link rel="stylesheet" href="/css/fontawesome.min.css" type="text/css" media="screen, projection" />
  <link rel="stylesheet" href="/css/base.css" type="text/css" media="screen, projection" />
  <link rel="stylesheet" href="/css/pygments.css" type="text/css" />
  <link media="only screen and (max-device-width: 480px)" href="/css/mobile.css" type="text/css" rel="stylesheet" />
  <link media="only screen and (device-width: 768px)" href="/css/mobile.css" type="text/css" rel="stylesheet" />
  <link href='http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz' rel='stylesheet' type='text/css'>
  <link rel="apple-touch-icon" href="/apple-touch-icon.png" />

  <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
  <script type="text/javascript" src="/js/application.js"></script>
</head>

<body>
  <section class="header">
	<h1>
	  <a href="/">Haikus in C</a>
	</h1>
  </section>

  <section class="sidebar">

    <section class="meta">
      <a href="https://github.com/haikus-in-c" target="_blank"><i class="icon icon-github"></i></a>
    </section>

    <section class="sections">
      <ul>
		<li><a href="/">home</a><li>
        <li><a href="/about.html">about</a></li>
        <li><a href="/posts.html">posts</a></li>
      </ul>
    </section>

	<section class="shoutout">
	  <p>made with help from <a href="https://github.com/mojombo/jekyll">jekyll</a> and an adapted theme from
		<a href="http://zachholman.com/">zach holman</a>.</p>
	</section>

  </section>

  <section class="content">
  
	<h1>
	  <a href="/posts/all-the-numbers">All the Numbers</a>
	</h1>
	
	<section class="byline">
	  by Ian Zapolsky, Aug 17, 2013
	</section>

	<p><p>Finding a great solution to a computer science problem is more about the journey
than the final destination. The process of working through this challenge is a good
example of how our initial instincs about how do something can be (read: usually
are) wrong, and require deeper thought and fine-tuning.</p>

<p>Here&rsquo;s a challenge: find the sum of all the four-digit numbers made up from 1, 2, 3,
and 4, non-repeating. Initially, this problem seems to have two steps in my mind:</p>

<ol>
<li>find/generate all the numbers</li>
<li>sum them.</li>
</ol>


<p>Below is C code that does just this. I generate all the numbers with nested for
loops, then run them each through a quick comparison method that checks for repeats.</p>

<div class="highlight"><pre><code class="c"><span class="kt">int</span> <span class="nf">find_sum_slow</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">arr</span> <span class="o">=</span> <span class="n">mallow</span><span class="p">(</span><span class="mi">24</span><span class="o">*</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)));</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">mallow</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)));</span>
    <span class="kt">char</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">sum</span><span class="p">,</span> <span class="n">cursor</span><span class="p">;</span>
    <span class="n">sum</span> <span class="o">=</span> <span class="n">cursor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="sc">&#39;1&#39;</span><span class="p">;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="sc">&#39;5&#39;</span><span class="p">;</span> <span class="n">a</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cur</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="sc">&#39;1&#39;</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="sc">&#39;5&#39;</span><span class="p">;</span> <span class="n">b</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">cur</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;1&#39;</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="sc">&#39;5&#39;</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">cur</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">d</span> <span class="o">=</span> <span class="sc">&#39;1&#39;</span><span class="p">;</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="sc">&#39;5&#39;</span><span class="p">;</span> <span class="n">d</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">cur</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">check_repeat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cur</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">arr</span><span class="p">[</span><span class="n">cursor</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
                        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">atoi</span><span class="p">(</span><span class="n">cur</span><span class="p">));</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">cursor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cursor</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="p">;</span> <span class="n">cursor</span><span class="o">++</span><span class="p">)</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">cursor</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">check_repeat</span><span class="p">(</span><span class="kt">char</span><span class="o">**</span> <span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">cur</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="o">*</span><span class="n">cur</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="n">cur</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="o">*</span><span class="n">cur</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">||</span>
        <span class="p">(</span><span class="o">*</span><span class="n">cur</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="o">*</span><span class="n">cur</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="n">cur</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="o">*</span><span class="n">cur</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">||</span>
        <span class="p">(</span><span class="o">*</span><span class="n">cur</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="o">*</span><span class="n">cur</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="n">cur</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="o">*</span><span class="n">cur</span><span class="p">)[</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>There are a couple things to note. First, we can tell that there will be 4! = 24 four-digit numbers because a non-repeating four-digit number made up of only four distinct integers can be comprised of 4*3*2*1 combinations of digits. Second, we can take advantage of the fact that ASCII characters are
ordered sequentially to get get chars 1-4 by incrementing the integer representation of that char.</p>

<p>However, after a bit more thought, and a helpful conversation with Ruchir, I realized that this
is actually a pretty horrible way of finding this sum. Let&rsquo;s think about the challenge in a
different way. We know there will be 4! of these four-digit non-repeating numbers. Now let&rsquo;s
take that knowledge a step further: if there are 4! total numbers, it follows that for each
given digit there will by 24/4 = 6 numbers that contain that digit in a given place. In other
words, if we fix one digit of the four-digit number, there will be 3! = 6 different numbers
that can be made with the other digits arranged in various ways around the single fixed number.</p>

<p>For example, there will be 6 numbers in the set of 24 that have the digit 1 in the 1s place,
6 more that have 1 in the 10s, 6 more with 1 in the 100s, and the final 6 will have a 1 in
the 1000s place. This idea expressed in math terms for our 4-digit example looks like this:</p>

<div class="highlight"><pre><code class="latex">sum = (1+2+3+4) * (10<span class="nb">^</span>0 + 10<span class="nb">^</span>1 + 10<span class="nb">^</span>2 +10<span class="nb">^</span>3) * (3!)
</code></pre></div>


<p>Using this observation, we can skip the memory and time intensive process of generating these
four-digit numbers and simply find the sum with the following simple algorithm, which uses
the idea from above to calculate the sum of all the n-digit numbers made up of integers
1-n non-repeating.</p>

<div class="highlight"><pre><code class="c"><span class="kt">int</span> <span class="nf">find_sum_fast</span><span class="p">(</span><span class="kt">int</span> <span class="n">digits</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">sum</span><span class="p">;</span>
    <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="n">digits</span><span class="p">;</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">a</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">digits</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">b</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span><span class="o">--</span><span class="p">)</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">digits</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">b</span><span class="o">--</span><span class="p">)</span>
        <span class="n">sum</span> <span class="o">*=</span> <span class="n">b</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<p>This post is a great example of why I wanted to start this blog in the first place: to explore
answers to problems like this and find them on my own, instead of just reading them off
sites like careercup.</p>
</p>

	<hr>

  
	<h1>
	  <a href="/posts/number-unique-elements">No Easy Questions</a>
	</h1>
	
	<section class="byline">
	  by Ruchir Khaitan, Aug 16, 2013
	</section>

	<p><p>Today, I&rsquo;m going to subvert a key principle of this blog for a little bit, namely the idea that an educational or even interesting probem has to be somewhat complex, hence the term programming puzzles. The problem I&rsquo;m going to examine today is simply: given a list of n objects (the code is only going to handle integers but the ideas apply equally well to all data), find the number of unique elements it contains. This question is simple enough that one doesn&rsquo;t need to be a compuuter scientist to solve it. All one has to do is, at each element, scan the remainder of the list. If you can find another element that matches the one you were looking at, obviously it&rsquo;s not unique. The code below expresses this algorithm in C:</p>

<div class="highlight"><pre><code class="java"> <span class="kt">int</span> <span class="nf">naive_find_num_unique</span><span class="o">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">array</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">){</span>
            <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">unique</span><span class="o">,</span> <span class="n">num</span><span class="o">;</span>
            <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
                    <span class="n">unique</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="k">for</span><span class="o">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">size</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
                            <span class="k">if</span><span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]==</span> <span class="n">array</span><span class="o">[</span><span class="n">j</span><span class="o">])</span>
                                    <span class="n">unique</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">unique</span><span class="o">)</span>
                            <span class="n">num</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">num</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div>


<p>You&rsquo;ll notice that I named this function &ldquo;naive_find_num_unique&rdquo; for a reason. This function, while very easy to understandd and very memory efficient, has horrible performance, because of its O(n<sup>2</sup>) time complexity, which occurs because given an input of size n, for each element i in n, we need to read the remainder of the list. Since the number of steps we need to read varies from (n-1) at the front, to zero at the end, meaning an average of about n/2 steps taken n times, it&rsquo;s clear that the algorithm takes k/2 * n<sup>2</sup> + b*n +c steps - but what matters is the O(n<sup>2</sup>). While this is bad, in the context of this problem this performance actually isn&rsquo;t too far from a theoretical maximum since in order to find the answer, any solution must look at every value at least once, and therefore, the optimal solution must be O(n).
Before we totally dismiss this most naive solution perhaps I should stress that it&rsquo;s still not worthless, rather this algorithm, because of its simplicity, is really good for quick and dirty initial solutions or for a system that has no memory to spare like some embedded systems. However, the question still remains: how low can you go (time complexity-wise)?</p>

<p>Its clear that in order to improve the performance of this algorithm, we need to speed up the slowest step. As it stands, the slowest step is scanning the remainder of the array, to check whether an equivalent value exists. One way to speed up this process is with a bit vector,which represents sets of data using single bits, a 1 meaning the element is in the set, and a 0 meaning it isnt. Our way forward is now clear, first, we initialize an array of bits to zero. Then, for each nth element in our array of data value, we check the corresponding nth bit in the bitvector. If this bit is zero, then that indicates that this element hasn&rsquo;t yet been seen and so we raise that bit, and scan the rest of the array, looking for equivalent elements, and if any are found, raising the bits at those indices. On the other hand, if the corresponding bit is high, then that indicates that we have already seen this element and so we can move forward.</p>

<div class="highlight"><pre><code class="java"> <span class="kt">int</span> <span class="nf">find_unique2</span><span class="o">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">array</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">num</span><span class="o">;</span>
            <span class="n">num</span> <span class="o">=</span><span class="mi">0</span><span class="o">;</span>
            <span class="kt">char</span><span class="o">*</span> <span class="n">bvector</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">*)</span> <span class="n">calloc</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">sizeof</span><span class="o">(</span><span class="kt">char</span><span class="o">));</span>
            <span class="k">for</span><span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
                    <span class="k">if</span><span class="o">(!</span><span class="n">bvector</span><span class="o">[</span><span class="n">i</span><span class="o">]){</span>
                            <span class="n">num</span><span class="o">++;</span>
                            <span class="n">bvector</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                            <span class="k">for</span><span class="o">(</span><span class="n">j</span> <span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">size</span><span class="o">;</span> <span class="n">j</span><span class="o">++){</span>
                                    <span class="k">if</span><span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">array</span><span class="o">[</span><span class="n">j</span><span class="o">])</span>
                                            <span class="n">bvector</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                            <span class="o">}</span>
                    <span class="o">}</span>    
            <span class="o">}</span>
            <span class="n">free</span><span class="o">(</span><span class="n">bvector</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">num</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div>


<p>Again there are a few caveats. First, this isn&rsquo;t a true bit vector, rather it&rsquo;s a byte vector, meaning that I&rsquo;m using eight times more memory than I ought to be, to the outrage of system engineers everywhere. In my defense, I&rsquo;m using four times less than I would be representing the data as an array of integers, I&rsquo;m only making one call to malloc(), and on the overwhelming majority of modern computers, memory is pretty much always available in excess.
Oh and yeah, this function&rsquo;s much faster, because now it only scans ahead sometimes rather than all the time. Despite this improvement however, the worst case runtime (which occurs when each element in the array is unique) is equivalent to the earlier solution. If you allow my logic that an array of n elements has m distinct elements contained within it, where n and m are both positive integers, then the runtime here will be O(mn), which is a better indicator than O(n<sup>2</sup>). Note however that since m = n/k where k is constant, the two are actually identical asymptotic upper bounds.
Basically, while I&rsquo;ve made searches faster, they still average out to a O(n) operation. The only way to escape this is to use a more complex data structure that lets me search faster, whether it contains what I&rsquo;m searching for or not.
One such data is a binary search tree. Trees in computer science are like trees in nature flipped pside down, with a &ldquo;root&rdquo; at the top, and &ldquo;leaves&rdquo; at the bottom. Each node of the tree has at most two &ldquo;children&rdquo; and one &ldquo;parent&rdquo;, hence binary tree, except leaves, which by definition have no children since they are the endpoints of the tree and the root, which has no parent. Finally, what makes it a binary search tree is the property that at any node n, n&rsquo;s left descendants (left chid, plus its kids, plus their kids) only contain values smaller than that contained in n, while n&rsquo;s right descendants only contain values larger than n. If this all sounds a bit insane, don&rsquo;t worry, because this is one of those times where code makes more sense than English ever could.</p>

<div class="highlight"><pre><code class="java"> <span class="n">struct</span> <span class="n">btree_node</span><span class="o">{</span>
            <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
            <span class="n">struct</span> <span class="n">btree_node</span><span class="o">*</span> <span class="n">parent</span><span class="o">;</span>
            <span class="n">struct</span> <span class="n">btree_node</span><span class="o">*</span> <span class="n">left</span><span class="o">;</span>
            <span class="n">struct</span> <span class="n">btree_node</span><span class="o">*</span> <span class="n">right</span><span class="o">;</span>
    <span class="o">};</span>

    <span class="n">struct</span> <span class="n">btree_node</span><span class="o">*</span> <span class="n">create_node</span><span class="o">(</span><span class="n">struct</span> <span class="n">btree_node</span><span class="o">*</span> <span class="n">parent</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">){</span>
            <span class="n">struct</span> <span class="n">btree_node</span><span class="o">*</span> <span class="n">newNode</span> <span class="o">=</span> <span class="o">(</span><span class="n">struct</span> <span class="n">btree_node</span><span class="o">*)</span> <span class="n">malloc</span><span class="o">(</span><span class="n">sizeof</span><span class="o">(</span><span class="n">struct</span> <span class="n">btree_node</span><span class="o">));</span>
            <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">NULL</span><span class="o">;</span>
            <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">NULL</span><span class="o">;</span>
            <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">newNode</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">void</span> <span class="nf">insert_node</span><span class="o">(</span><span class="n">struct</span> <span class="n">btree_node</span><span class="o">**</span> <span class="n">node</span><span class="o">,</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="n">struct</span> <span class="n">btree_node</span><span class="o">*</span> <span class="n">parent</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(*</span><span class="n">node</span> <span class="o">==</span> <span class="n">NULL</span><span class="o">){</span>
                    <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">create_node</span><span class="o">(</span><span class="n">parent</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
                    <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">&lt;(*</span><span class="n">node</span><span class="o">)-&gt;</span><span class="n">value</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">insert_node</span><span class="o">(&amp;((*</span><span class="n">node</span><span class="o">)-&gt;</span><span class="n">left</span><span class="o">),</span> <span class="n">x</span><span class="o">,</span> <span class="o">*</span><span class="n">node</span><span class="o">);</span>
                    <span class="k">return</span><span class="o">;</span>
                <span class="o">}</span>

            <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">&gt;(*</span><span class="n">node</span><span class="o">)-&gt;</span><span class="n">value</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">insert_node</span><span class="o">(&amp;((*</span><span class="n">node</span><span class="o">)-&gt;</span><span class="n">right</span><span class="o">),</span> <span class="n">x</span><span class="o">,</span> <span class="o">*</span><span class="n">node</span><span class="o">);</span>
                    <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">struct</span> <span class="n">btree_node</span><span class="o">*</span> <span class="n">bst_search</span><span class="o">(</span><span class="n">struct</span> <span class="n">btree_node</span><span class="o">*</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">==</span><span class="n">NULL</span><span class="o">)</span>
                    <span class="k">return</span> <span class="n">NULL</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">==</span> <span class="n">x</span><span class="o">)</span>
                    <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">&lt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">)</span>
                    <span class="k">return</span> <span class="nf">bst_search</span><span class="o">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>

            <span class="k">return</span> <span class="nf">bst_search</span><span class="o">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></div>


<p>Now, the organization of data within a binary search tree lets us easily perform a much faster binary search, letting us potentially halve the number of options we have to look at with every step. Of course, this comes with some negatives, as now insertions require a search to find the appropriate location to place the element. Also, the data structure requires more memory managements, meaning more malloc()s and frees()s.Unfortunately, in order to achieve speed gains in computer science, we often have to trade that against negatives like higher memory use, or more complex implementations. However, in this case, once the data structure is fully set up (the entire code is on <a href="https://github.com/haikus-in-c/haikus-in-c/tree/master/2013.8/find_unique_element">Github</a>), then the algorithm to compute the number of unique elements is essentially the same as that used above, only with a binary search tree in place of a bitvector.</p>

<div class="highlight"><pre><code class="java"><span class="kt">int</span> <span class="nf">find_bst</span><span class="o">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">array</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">){</span>
        <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">num</span><span class="o">;</span>
        <span class="n">struct</span> <span class="n">btree_node</span><span class="o">*</span> <span class="n">root</span> <span class="o">=</span> <span class="n">init_tree</span><span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
        <span class="n">num</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">bst_search</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">])){</span>
                        <span class="n">num</span><span class="o">++;</span>
                        <span class="n">insert_node</span><span class="o">(&amp;</span><span class="n">root</span><span class="o">,</span> <span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">NULL</span><span class="o">);</span>
                <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">//print_rec(root, 0);</span>
        <span class="n">free_tree</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">num</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>


<p>Now, this function takes O(n* log n) since there are n elements, and because of the nature of the binary searches required for insert and search, which are both O(log n) operations as if n were to double, that would only really add one more level or one more node for those functions to go through. At this point however, I have to address the fact that these are not facts/laws that are true always, but rather assumptions that are true in general. Imagine an evil user inputing 1, then 2, then 3 and so on. The root would have one child which would have one child and so on. That&rsquo;s not a tree, that&rsquo;s a grapevine! It&rsquo;s more like a linked list, but that doesn&rsquo;t really extend the botanical annalogy. Still, in the worst case, these operations are still O(n) meaning in the worst case, I&rsquo;m not any better off than when I started.
That sucks. Really, if I&rsquo;m going to spend so much time building a system that performs at a high level, I can&rsquo;t let it get tripped up by something as common as a set of sorted inputs. That could happen at any time. Of course, if I could check my inputs in advance, I could check in linear time if it was sorted, and then compute the number of unique elements in linear time as well (by comparing adjacent values) but I want a different option, a data structure that works for me in O(log n) or better for inserts and searches no matter what.
One such structure is the red-black tree, which is a self-balancing tree, meaning that, if the tree starts to form a nonoptimal, vinelike shape, it will automatically balance itselfback into a more even tree where most elements have two children. One important thing to note here is that self-balancing means that the &ldquo;root&rdquo; node can change from time to time, and so we need a tree struct to go along with a node struct.
The full details of a red-black trees theory are fairly complex and probably better explained <a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree">here</a>. The two key takeaways are that implementing a red-black tree requires rotations, which are symmetrical operations that take a node X and its left child Y and transform it into a node Y with a right child X (corresponding to a right rotation of X) or vice versa, (which corresponds to a left rotation of Y). Basically all rotations on a node, whether left or right are given in context of a node and its right or left child respectively. I&rsquo;ve attached the code for a left rotation below to help clarify.</p>

<div class="highlight"><pre><code class="java"> <span class="c1">//Here rb_wrap is a wrapper class for red black trees </span>
    <span class="c1">//and rb_tree is a class for reb-black tree nodes that&#39;s identical to btree_node </span>
    <span class="kt">void</span> <span class="nf">left_rotate</span><span class="o">(</span><span class="n">struct</span> <span class="n">rb_wrap</span><span class="o">*</span> <span class="n">rb_tree</span><span class="o">,</span> <span class="n">struct</span> <span class="n">rb_tree</span><span class="o">*</span> <span class="n">node</span><span class="o">){</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">node</span><span class="o">)</span>
                    <span class="k">return</span><span class="o">;</span>
            <span class="n">struct</span> <span class="n">rb_tree</span><span class="o">*</span> <span class="n">right_child</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">right_child</span><span class="o">)</span>
                    <span class="k">return</span><span class="o">;</span>
            <span class="c1">//printf(&quot;performing left rotate on node value: %d\n&quot;, node-&gt;value);</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">right_child</span><span class="o">-&gt;</span> <span class="n">left</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">right_child</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">)</span>
            <span class="k">if</span><span class="o">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">){</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">){</span>
                            <span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">right_child</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="k">else</span> <span class="o">{</span>
                            <span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">right_child</span><span class="o">;</span>
                    <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">rb_tree</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">==</span> <span class="n">node</span><span class="o">)</span>
                    <span class="n">rb_tree</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">right_child</span><span class="o">;</span>

            <span class="n">right_child</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">node</span><span class="o">;</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">right_child</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div>


<p>The second key takeaway is that insertions become horrendously complicated, with a long sequence of rules, checks and cases (5 when you take away left/right duplicates) and transformations that are difficult to remember, hard to implement correctly, and add a real world operational cost not visible when you&rsquo;re just looking at big-O runtimes. Now, when we use red-bllack trees in the algorithm to determine the number of unique values, it will have O(n log n) performance, but is it worth it if I could never code red black trees without consulting a book or two?
Fortunately, there is a another option, a balanced data structure thats easy to understand and easy to get running. It&rsquo;s called skip lists, and the best analogy I can give for them actually goes to something very dear to my New Yorker heart (I&rsquo;ve lived there two whole years): the subway. Say you want to go from Times Square to Williamsburg. Only a fool (or a tourist) would take local lines all the way there as the express trains save time by &ldquo;skipping&rdquo; stops that aren&rsquo;t very popular. Now imagine that there were a third line, with stops at lets say Times Square, the bridge (which is kind of like a midpoint), and somewhere in Williamsburg. For you, this hypothetical third line would be the best option since it &ldquo;skips&rdquo; even more stops. A skip list is like this expanded subway, only with K lines instead of two or three, and a base linne that connects all the data and is basically an ordered linked list.</p>

<p>From there search should be pretty intuitive (definitely for the New Yorkers). You search just as you would travel: take the best express as far as it can take you wthout going over, then the next, then the next, until finally you reach your stop. Inserts should be familiar to anyone who&rsquo;s dealt with sorted linked lists; you just do a search until you figure out between which two nodes your element should go and then you re-route the links to attach the new element in the middle.
Really, the only remaining question is how do we determine how many express lines (levels) a node is connected to? Sure, every node connects at least on the base levels, but what about the ones above that, the expresses? In New York&rsquo;s subway, and subways worldwide, this is setted by a popularity contest. Since everyone loves Times Square, its connected to (every) express. Columbia, not so much. Unfortunately, we can&rsquo;t know which elements are going to be accessed most often in all cases, so that approach goes out the window. <br/>
Insted, we just toss coins. Fifty-fifty shot it connects to level two. If it does, fifty-fifty shot it connects to level three, and so on. That way, each level up will contain approximately half of the nodes compared to the level below it, and to search, going to the first node in the topmost level would put you near the middle of the base linked list (on average). Then you could go down and search as you please in O(log n) time. This amortized analysis of average runtime is slightly different from the average case/worst case performance of a binary search tree because here, there is no worst case. The performance tends to O(log n) because the data structure isn&rsquo;t fully deterministic, and coin tosses tend to be pretty close to even heads and tails. It&rsquo;s possible, though unlikely, that you could insert ten elements and have them all only link on the base level leading to a worst case O(n) runtime. But the difference is, this result isn&rsquo;t repeatable, it&rsquo;s random.</p>

<p>This solves all the conceptual problems, but leaves us dependent on random number generators to dictate our coin toss. I decided instead that a coin toss is the same as a bit being low or high, or a number being odd/even and made the number of levels a given node has dependant on the size of the linked list at the moment. Essentially, if a node is the third node inserted into a skip list, it will connect only at the bottom level (level 0) since it doesn&rsquo;t divide evenly by two, or to put it another way, its zero order bit is high. Instead, if its the fourth node to be inserted, it will connect on level 0, 1, and 2, since it divides by 2 and four, or to put it another way, its second order bit is the first high bit. This method is faster than using a random number generator at every &ldquo;coin toss&rdquo; and I guess all that&rsquo;s left is to show you the code.</p>

<div class="highlight"><pre><code class="java"><span class="n">struct</span> <span class="n">skip_node</span><span class="o">{</span>
        <span class="n">struct</span> <span class="n">skip_node</span><span class="o">**</span> <span class="n">array</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">data</span><span class="o">;</span>
<span class="o">};</span>

<span class="n">struct</span> <span class="n">skip_list</span> <span class="o">{</span>
        <span class="n">struct</span> <span class="n">skip_node</span><span class="o">*</span> <span class="n">head</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">levels</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>       <span class="c1">//number inserted</span>
        <span class="kt">int</span> <span class="n">curr_level</span><span class="o">;</span>
<span class="o">};</span>
<span class="kt">int</span> <span class="nf">search_skip_list</span><span class="o">(</span><span class="n">struct</span> <span class="n">skip_list</span><span class="o">*</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="o">;</span>
        <span class="n">struct</span> <span class="n">skip_node</span><span class="o">*</span> <span class="n">curr</span><span class="o">,</span> <span class="o">*</span><span class="n">prev</span><span class="o">;</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="n">i</span> <span class="o">=</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">levels</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--){</span>
                <span class="k">while</span><span class="o">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span><span class="n">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]-&gt;</span><span class="n">data</span> <span class="o">&lt;</span><span class="n">value</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">curr</span><span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">array</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="k">if</span><span class="o">(</span><span class="n">curr</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">value</span><span class="o">)</span>
                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>
<span class="n">struct</span> <span class="n">skip_node</span><span class="o">*</span> <span class="n">insert_skip_list</span><span class="o">(</span><span class="n">struct</span> <span class="n">skip_list</span><span class="o">*</span> <span class="n">list</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">){</span>
        <span class="n">struct</span> <span class="n">skip_node</span><span class="o">**</span> <span class="n">touched</span> <span class="o">=</span> <span class="o">(</span><span class="n">struct</span> <span class="n">skip_node</span><span class="o">**)</span> <span class="n">calloc</span><span class="o">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">levels</span><span class="o">,</span> <span class="n">sizeof</span><span class="o">(</span><span class="n">struct</span> <span class="n">skip_node</span><span class="o">*));</span>
        <span class="n">list</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++;</span>
        <span class="n">struct</span> <span class="n">skip_node</span><span class="o">*</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">node_level</span><span class="o">;</span>
        <span class="n">node_level</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">levels</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--){</span>
                <span class="k">while</span><span class="o">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="n">NULL</span>  <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]-&gt;</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">//      printf(&quot;Curr data in insert %d\n&quot;, curr-&gt;data);</span>
                        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                <span class="o">}</span>
                <span class="n">touched</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">curr</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">array</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="c1">//printf(&quot;Final curr data in insert %d\n&quot;, curr-&gt;data);</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">curr</span> <span class="o">||</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">!=</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">exp</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="kt">int</span> <span class="n">test</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">;</span>
                <span class="k">for</span><span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">levels</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
                        <span class="n">exp</span> <span class="o">=</span> <span class="n">exp</span><span class="o">*</span><span class="mi">2</span><span class="o">;</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">exp</span> <span class="o">&lt;=</span> <span class="n">test</span> <span class="o">&amp;&amp;</span> <span class="n">test</span><span class="o">%(</span><span class="n">exp</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
                                <span class="n">node_level</span><span class="o">++;</span>
                        <span class="c1">//      test = test/2;</span>
                        <span class="o">}</span>
                         <span class="k">else</span><span class="o">{</span>
                                <span class="k">break</span><span class="o">;</span>
                        <span class="o">}</span>
                <span class="o">}</span>

                <span class="n">struct</span> <span class="n">skip_node</span><span class="o">*</span> <span class="n">new_node</span><span class="o">=</span> <span class="n">create_skip_node</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">node_level</span><span class="o">);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">node_level</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">curr_level</span><span class="o">){</span>
                        <span class="k">for</span><span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">curr_level</span> <span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">levels</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                                <span class="n">touched</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">head</span><span class="o">;</span>
                        <span class="o">}</span>
                        <span class="n">list</span><span class="o">-&gt;</span><span class="n">curr_level</span> <span class="o">=</span> <span class="n">node_level</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">for</span><span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">node_level</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">touched</span><span class="o">[</span><span class="n">i</span><span class="o">]-&gt;</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                        <span class="n">touched</span><span class="o">[</span><span class="n">i</span><span class="o">]-&gt;</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">new_node</span><span class="o">;</span>
                <span class="o">}</span>
        <span class="o">}</span>
        <span class="n">free</span><span class="o">(</span><span class="n">touched</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>


<p>However, one important factor that changes by using this method is that now the data structure isn&rsquo;t truly randomized, since the heads/tails come at fixed intervals and so, there now exists a &ldquo;worst-case&rdquo; input, which I&rsquo;ll leave you to figure out (hint: it involves trees). Stilll, the key principles of skip lists remain, only a little more ordered, and I finally got a solution working in O(n og n) that I could explain to my little sister and/or grandma.
Finally, I think we&rsquo;ve done everything we can except for hash tables. I&rsquo;m choosing not to cover that because frankly, I think they are a pretty large subject within data structures/algorithms more deserving of a larger post dedicated solely for them, and more importantly, so much  of a given hash tables performance boils down to its hash function, which I think that if you are going to invest the time to write your own should be tailored to perform well on expected data. That being said, I&rsquo;d be remiss not to point out that hash tables could help us perform the algorithm in O(n).
At the end of this long post, I feel a bit like a man who&rsquo;d spent many hours trying to draw a perfect circle, or carve a surfboard, because my effort was largely unnecessary, given that all modern languages have good, if not great libraries for all kinds of data structures. Nobody really NEEDS to do this. However, I think learning some things, especially highly abstract stuff like this, is pretty difficult if you&rsquo;re just reading or listening to facts, theories or histories. In order to really understand, I have to question, to poke and prod, even grapple with an idea in the wild before I learn anything. Also, most of computer science is the analysis of either breaking complex problems into simple ones, or optimizing the hell out of solutions to &ldquo;easy&rdquo; problems. Google, for example, deals primarily with search, which is something every intro CS course covers. Just goes to show that even the simplest things, when made fast enough, can be worth a lot.</p>
</p>

	<hr>

  
	<h1>
	  <a href="/posts/triangle-sum">Yodle Programming Challenge: Triangle Sums</a>
	</h1>
	
	<section class="byline">
	  by Ruchir Khaitan, Aug 15, 2013
	</section>

	<p><p>Today&rsquo;s puzzle is an exercise in recursion and iteration, and the costs and benefits of both. The task is simple, given a triangle of numbers, here defined as an arrangement of numbers where the first row has one number, the second row has two, and the nth row has n numbers, the task is to find the maximum total going from top to bottom using only adjacent numbers, or the maximum path sum. A sample triangle and top down path are shown below. The challenge is to do this for a large triangle, with at least a hundred rows, where there are so many top down paths that brute force solutions are impossible.</p>

<div class="highlight"><pre><code class="latex">        1           max path: 1
      3   5                   5 
    6   7   2                 7
                    total:   13 
</code></pre></div>


<p>There are two key questions that need to be answered in order to solve this problem. Firstly, how are we going to represent the triangle so that the program can use the data? One initially attractive solution is to use a tree structure, since the shape of a triangle suggests a tree almost immediately and each node would only have two children. However, this approach falls short, as though each parent node would have two child nodes, most of those nodes would be shared between two parents, which could lead to memory usage and implementation complications. Instead, lets examine what we know. We know that each triangle will only ever have n rows, and that each nth row will have n numbers. This means that if the triangle is represented as a text file, then just by counting the number of lines we can know that there will be n(n+1)/2 elements, which can be stored in an array.</p>

<div class="highlight"><pre><code class="java"> <span class="kt">int</span><span class="o">*</span> <span class="n">triangle</span> <span class="o">=</span> <span class="n">malloc</span><span class="o">(</span><span class="n">sizeof</span><span class="o">(</span><span class="kt">int</span><span class="o">)*(</span><span class="n">numLine</span><span class="o">*(</span><span class="n">numLine</span><span class="o">+</span><span class="mi">1</span><span class="o">))/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="k">while</span><span class="o">(</span><span class="n">fgets</span><span class="o">(</span><span class="n">buf</span><span class="o">,</span> <span class="n">sizeof</span><span class="o">(</span><span class="n">buf</span><span class="o">),</span> <span class="n">file</span><span class="o">))</span> <span class="o">{</span>  
                <span class="n">num</span> <span class="o">=(</span><span class="kt">int</span><span class="o">)</span>  <span class="n">strtol</span><span class="o">(</span><span class="n">buf</span><span class="o">,</span> <span class="o">&amp;</span><span class="n">numEnd</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span>
            <span class="k">do</span> <span class="o">{</span>
                    <span class="n">triangle</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
                        <span class="n">j</span><span class="o">++;</span>
                <span class="o">}</span> <span class="k">while</span><span class="o">(</span><span class="n">num</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">strtol</span><span class="o">(</span><span class="n">numEnd</span><span class="o">,</span> <span class="o">&amp;</span><span class="n">numEnd</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span> <span class="o">);</span>
            <span class="o">}</span>        
            <span class="n">fclose</span><span class="o">(</span><span class="n">file</span><span class="o">);</span>  <span class="c1">//Continued below</span>
</code></pre></div>


<p>So then the second question is whats the most efficient way to compute the maximum path? One approach is the pure recursive approach which I also like to call the top-down approach. Here, the basic procedure is: start at the top, and find the maximum path sum from the left and right children and return the greater sum + root node (the node the method was called on) value. In the base case, when a node doesn&rsquo;t have any children, it simply returns its own value. One advantage of the array implementation is that to go from parent to child, we dont need links, we can use array offsets because once we know the array index of a node, its left child&rsquo;s index is the array index + its row number and the right child&rsquo;s index is the left child&rsquo;s index + 1.</p>

<div class="highlight"><pre><code class="java"> <span class="kt">long</span> <span class="nf">recPathSum</span><span class="o">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">root</span><span class="o">,</span><span class="kt">int</span> <span class="n">rowNum</span><span class="o">,</span><span class="kt">int</span> <span class="n">triSize</span><span class="o">,</span><span class="kt">long</span> <span class="n">currSum</span> <span class="o">)</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">leftSum</span><span class="o">,</span> <span class="n">rightSum</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">rowNum</span> <span class="o">==</span> <span class="n">triSize</span><span class="o">)</span> 
            <span class="k">return</span> <span class="n">currSum</span> <span class="o">+</span> <span class="o">*(</span><span class="n">root</span><span class="o">);</span>
            <span class="kt">int</span><span class="o">*</span> <span class="n">child1</span> <span class="o">=</span> <span class="n">root</span> <span class="o">+</span> <span class="n">rowNum</span><span class="o">;</span>
            <span class="kt">int</span><span class="o">*</span> <span class="n">child2</span> <span class="o">=</span> <span class="n">child1</span><span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">currSum</span> <span class="o">+=</span> <span class="o">*</span><span class="n">root</span><span class="o">;</span>

            <span class="n">leftSum</span> <span class="o">=</span> <span class="n">recPathSum</span><span class="o">(</span><span class="n">child1</span><span class="o">,</span> <span class="n">rowNum</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="n">triSize</span><span class="o">,</span><span class="n">currSum</span><span class="o">);</span>
            <span class="n">rightSum</span> <span class="o">=</span> <span class="n">recPathSum</span><span class="o">(</span><span class="n">child2</span><span class="o">,</span> <span class="n">rowNum</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">triSize</span><span class="o">,</span> <span class="n">currSum</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">leftSum</span> <span class="o">&gt;</span> <span class="n">rightSum</span><span class="o">)</span> 
            <span class="k">return</span> <span class="n">leftSum</span><span class="o">;</span>
            <span class="k">return</span> <span class="n">rightSum</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre></div>


<p>This algorithm works for small triangles but it takes far too long for larger ones. Why? Here recursion fails because the program doesn&rsquo;t reduce the amount of computation needed with each recursive step. Say we have a 100 row triangle and we run this function. After one level of recursion, we have two 99 row triangles. Another level of recursion deeper, we get four 98 row triangles. Thus, in this instance, recursion is actually making the problem exponentially larger.</p>

<p>Another, much faster solution is the bottom-up way, which I also call the iterative solution. The key insight is that the second to last row of numbers is also a row of small triangles each with only two rows. For those, finding the maximum path sum is easy. Note - Theres no need to write new code for that computation, we can reuse the recursive method. So, we replace each sub-triangle&rsquo;s root node with a number representing the maximum path sum through it. Thus, the bottom two rows can be resolved into one row of numbers corresponding to the maximum path sums from each of the nodes on that row. From there, we can move up to the next row being careful to always look only one row below the one we are currently on, and we can quickly work our way up to the top. Eventually, the root node will contain the maximum path sum.</p>

<div class="highlight"><pre><code class="java"> <span class="kt">long</span> <span class="nf">iterativePathSum</span><span class="o">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">triSize</span><span class="o">)</span> <span class="o">{</span> 
        <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="n">j</span> <span class="o">,</span> <span class="n">k</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">triSize</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
                <span class="kt">int</span><span class="o">*</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">root</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span><span class="o">*(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">))/</span><span class="mi">2</span><span class="o">;</span>   
                <span class="k">for</span><span class="o">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="o">*(</span><span class="n">offset</span><span class="o">+</span><span class="n">j</span><span class="o">)</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">recPathSum</span><span class="o">((</span><span class="n">offset</span><span class="o">+</span><span class="n">j</span><span class="o">),</span><span class="n">i</span><span class="o">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span> 
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="o">*(</span><span class="n">root</span><span class="o">);</span>

    <span class="o">}</span> 
</code></pre></div>


<p>Obviously, this approach is destructive and totally overwrites the data stored in the array, but copying over an array of elements doesnt take too much time or space, and so, in this case, the benefits far outweigh the costs.</p>
</p>

	<hr>

  
	<h1>
	  <a href="/posts/github-pages-custom-domain">Foolproof Guide to Github Pages with a Custom Domain</a>
	</h1>
	
	<section class="byline">
	  by Ian Zapolsky, Aug 15, 2013
	</section>

	<p><p>Recently I spent some time wading through the internet&rsquo;s primordial soup of CS help sources - Stack
Overflow commments, random blogs (like this one!), and source documentation that leaves something to
be desired - to set up this site, which is hosted on Github Pages with a custom domain. I&rsquo;ve since
decided to migrate the hosting of my <a href="http://ianzapolsky.com/">personal website</a> to Github Pages as well,
because it&rsquo;s such a great platform and allows for almost instantatneous editing and changing. Instead
of using clumsy cPanels and browser-based editors, you can just make edits to your site files
locally in whatever text editor you want, add, commit, push, and it&rsquo;s live. However, there are
a couple tricky spots to getting your custom domain Github Pages hosted site up and running.
But since I&rsquo;ve done this setup process twice now, I&rsquo;m going to cover it from scratch,
so I can garuntee that by the end of this, your website will work too!</p>

<p>I&rsquo;m only going to assume one thing for this tutorial: that you already have a Github account. If you
don&rsquo;t that&rsquo;s no problem, just go set one up and follow their super clear instructions verbatim. Then
come back here.</p>

<p>Now, first thing&rsquo;s first. If you don&rsquo;t own the domain you want to use, go buy it.  Having used
<a href="http://www.godaddy.com/">GoDaddy</a> before, I can tell you that it kind of sucks, and is in no way meant for
anyone who considers themself to be even a shadow of a hacker. I&rsquo;ve also tried <a href="http://www.dreamhost.com/">DreamHost</a>
which has a much cleaner interface than GoDaddy, but doesn&rsquo;t offer that much more in the way of
features. Finally, I&rsquo;ve read good things about <a href="http://www.namecheap.com/">Namecheap</a>, but have never personally
tried it. Ultimately, these services all do the same things, and where you buy your domain from
doesn&rsquo;t matter, as long as they aren&rsquo;t some scam company.</p>

<p>Once you own your domain, pull up your Github account page and create a new repository. Name
it your-username.github.io. The Github account for this blog is haikus-in-c, so the Github repository
that this site is hosted out of is named haikus-in-c.github.io. It must be named this way for
Github Pages reasons, and it is important. Now, set up a version on your local machine:</p>

<pre><code>$ mkdir ~/your-username.github.io
$ cd ~/your-username.github.io
$ git init
$ touch CNAME   // add this file, but leave it blank for now
$ git commit -m 'first commit'
$ git remote add origin https://github.com/your-username/your-username.github.io.git
$ git push origin master
</code></pre>

<p>Excellent. Now you have a repository on your local machine pointing to your-username.github.io on
Github&rsquo;s servers. This directory will hold the body of your site, and it&rsquo;s kind of like a more advanced
version of a public_html directory. I say more advanced because Github Pages repositories are also capable of building <a href="http://jekyllrb.com/docs/home/">Jekyll</a> sites. <em>A lot</em> of Github Pages users use Jekyll, which is a ruby based platform
that transforms text files into static websites and blogs, because Github itself actually uses Jekyll
to serve every page it hosts. If you are setting up a blog but haven&rsquo;t yet considered using Jekyll,
I recommend <a href="http://jekyllrb.com/docs/home/">looking into it</a>.</p>

<p>Regardless of whether or not you&rsquo;re using Jekyll, the next step is to add your site files, or better yet
a simple test site that you know will build (a single index.html file with some test content will work fine,
or you could use the <a href="https://github.com/jekyll/test-site">Jekyll test site</a>). Once your site files are in your site directory like
you want them, git add, commit, and push up to the master branch of your-username.github.io:</p>

<pre><code>$ git add *
$ git commit -m 'added test site'
$ git push origin master
</code></pre>

<p>Now, in your web browser navigate to www.your-username.github.io. If you&rsquo;re looking at the
result of whatever HTML, Jekyll, or other types of files you just pushed to the your-username.github.io
repository, then you&rsquo;re ready to move on. If you&rsquo;re looking at a 404 page, or some other type of error, it&rsquo;s
probably one of two things. Either the Github servers haven&rsquo;t updated to see your freshly pushed data yet
(though in my experience this always happens really quickly), or your site didn&rsquo;t build for some reason. You
should also recieve an email from Github when this happens. There are a number of possible problems that
can cause this to happen: check the <a href="https://github.com/github/pages-gem/blob/master/github-pages.gemspec#L16">software versions</a> that the Github Pages' servers use
and make sure they&rsquo;re not causing any problems with your site. If that&rsquo;s not it, try building your site
on your local machine (if you&rsquo;re using Jekyll this is really easy). See the <a href="https://help.github.com/categories/20/articles">github docs</a> for
more troubleshooting.</p>

<p>Once you&rsquo;ve got a site showing at www.your-username.github.io you&rsquo;re finally ready to add your custom domain.
cd back into your-username.github.io and, using your favorite text editor, change CNAME to contain your
domain name. Use <a href="https://github.com/haikus-in-c/haikus-in-c.github.io/blob/master/CNAME">ours</a> as an example. Then type:</p>

<pre><code>$ git add *
$ git commit -m 'added domain to CNAME'
$ git push origin master
</code></pre>

<p>Now, go back to the site where you bought your domain from and navigate to whichever account page allows you to
manage your domains. Then click on the link that says something like &ldquo;DNS&rdquo; or &ldquo;Edit DNS&rdquo;. You can learn more
about DNS <a href="http://en.wikipedia.org/wiki/Domain_Name_System">here</a>, but basically what we&rsquo;re doing here is telling the internet that anytime it recieves
a request for your domain name, it should point whoever is sending that request to the Github Pages
servers, which is where your site now lives.</p>

<p>Using the DNS editing options, add an A record from your domain&rsquo;s root apex that points to the IP address 204.232.175.78,
which is Github Pages' server, and a CNAME record from &lsquo;www&rsquo; that points to your root apex (or the hostname of your site).</p>

<p>Note that there is a difference between the way GoDaddy and DreamHost handle the root apex and the www.
If you&rsquo;re using GoDaddy, you must add an A record from &lsquo;@&rsquo; (the root) pointing to the IP address given above, and
a CNAME record pointing from &lsquo;www&rsquo; to &lsquo;@&rsquo;. If you&rsquo;re using DreamHost, you have to add an A record with no name (which
DreamHost automatically interprets to be the root apex) that points to the Github IP address, and then
a CNAME record pointing from &lsquo;www&rsquo; to your-username.github.com (as opposed to &lsquo;@&rsquo;). Below are screenshots of the DNS edit screens looking the way they should for GoDaddy, then DreamHost.</p>

<p>GoDaddy: note that &lsquo;@&rsquo; (top) is set to point to 204.232.175.78 and &lsquo;www&rsquo; (bottom) points to &lsquo;@&rsquo;
<img src="/images/godaddy_img.png" alt="GoDaddy" />
DreamHost: note that there&rsquo;s an A record with a blank name pointing to 204.232.175.78 (which means the same
as GoDaddy&rsquo;s &lsquo;@&rsquo;) and a CNAME record pointing from &lsquo;www&rsquo; to ianzapolsky.github.com.
<img src="/images/dreamhost_img.png" alt="DreamHost" /></p>

<p>Wait a while for these DNS changes to propogate through the system, and your Github Pages hosted site should
be live on your custom domain!</p>
</p>

	<hr>

  
	<h1>
	  <a href="/posts/bash-todo-list-tool">todo -t write-todo-blog-post</a>
	</h1>
	
	<section class="byline">
	  by Ian Zapolsky, Aug 11, 2013
	</section>

	<p><p>Recently I read an <a href="http://zachholman.com/posts/inbox-zero-everything-zero/">article by Zach Holman</a>, an engineer at Github and the guy
whose jekyll theme I adapted to build this site, about a simple (read: <em>very</em> simple)
todo script he wrote to keep track of his tasks. Here&rsquo;s how it works: any time you&rsquo;re at
the shell, you can type:</p>

<pre><code>$ todo thing-i-have-to-do
</code></pre>

<p>This touches a file at ~/Desktop/thing-i-have-to-do. Here&rsquo;s the code of the script itself.</p>

<div class="highlight"><pre><code class="bash"><span class="c">#!/bin/sh</span>
<span class="nb">set</span> -e

touch ~/Desktop/<span class="s2">&quot;$*&quot;</span>
</code></pre></div>


<p>Obviously, this tool assumes that the user keeps a tidy Desktop and cleans it regularly. Otherwise,
it just wouldn&rsquo;t be feasible to keep track of all the todo files. In his own words, <a href="http://zachholman.com/posts/inbox-zero-everything-zero/">Zach writes</a>,</p>

<blockquote><p>I keep a clean desktop: under three icons at a time, preferably. It made sense to use my
desktop as a kind of bucket I need to empty&hellip;.</p></blockquote>

<p>Unfortunately, my desktop isn&rsquo;t so clean. I&rsquo;ve got all sorts of music and image files lying around,
in addition to miscellaneous stuff that&rsquo;s not related at all to programming. So, I decided to heavily
edit this todo script to accept several command line options that allow a user to set a priority for
a task (top - mid - low), print all the tasks in the todo list, organized by priority, and remove any
task. All the task files, which are the exact same empty files created with the touch command as in
Holman&rsquo;s original, are organized under one directory at ~/Desktop/todo. Within todo, there are three
more directories, todo/top, todo/mid, and todo/low. Each of these represents one priority category.</p>

<p>With my script, any time you&rsquo;re at the shell you can type:</p>

<pre><code>$ todo -t top-priority-thing
$ todo -m mid-priority-thing
$ todo -l low-priority-thing
$ todo other-top-priority-thing
</code></pre>

<p>The options -t, -m, and -l add a given task to directories top, mid, and low, respectively. If we run
todo without any option, our task will be automatically added to the top priority category. This is all
good, but we still have a problem when we want to peruse our list. It&rsquo;s all bundled up inside directories,
and none of us want to cd back and forth or fiddle with finder to see everything. That&rsquo;s where this
prompt comes in, which prints the todo list to the shell in an organized manner.</p>

<pre><code>$ todo -p
</code></pre>

<p>Assuming our previous input, this would return:</p>

<div class="highlight"><pre><code class="bash">/// TOP PRIORITY ///
  - other-top-priority-thing
  - top-priority-thing

/// MID PRIORITY ///
  - mid-priority-thing

/// LOW PRIORITY ///
  - low-priority-thing
</code></pre></div>


<p>Boom! Finally, one last thing. Removing tasks is probably the easiest operation to complete using just
regular command line tools. However, for those who are lazy, there&rsquo;s this command, which deletes
any task you want, so long as you provide the priority directory.</p>

<pre><code>$ todo -r mid/mid-priority-thing
</code></pre>

<p>That&rsquo;s all, a little todo tool to help you keep track of the stuff you&rsquo;re doing. Thanks to Zach for
getting the ball rolling. For those interested, here&rsquo;s the <a href="https://github.com/haikus-in-c/haikus-in-c/blob/master/2013.8/todo/todo">full version of my adapted todo script</a>.</p>
</p>

	<hr>

  
	<h1>
	  <a href="/posts/jugglefest">Can You Yodle and Juggle at the Same Time?</a>
	</h1>
	
	<section class="byline">
	  by Ian Zapolsky, May 24, 2013
	</section>

	<p><p>In the careers section of startup <a href="http://www.yodle.com/">Yodle&rsquo;s</a> website, there are a couple programming
problems, one of which is called <a href="http://www.yodlecareers.com/puzzles/jugglefest.html">JuggleFest</a>. Here&rsquo;s a summary: given a
list of x circuits and y jugglers, where each juggler has a certain number of circuit
preferences ranked 1 - n, assign the jugglers to circuits evenly such that the number of
jugglers in each circuit is y/x and no juggler could switch to a circuit that they prefer
more than the one they are already assigned to <em>and</em> be a better fit for that circuit than
one of the other jugglers assigned to it. Whew.</p>

<p>We determine how good a match a juggler is for a circuit by taking the dot product of three
variables which they all share: Hand-eye Coordination (H), Endurance (E), and Pizzazz (P).
The higher the dot product of a juggler with a specific circuit, the better fit a juggler
is for that circuit.</p>

<p>This problem is a great exercise in designing an airtight algorithm from small scale to
large scale. The sample input provided by Yodle gives us 3 circuits and 12 jugglers,
while the actual text file required to solve the challenge has 2,000 circuits and 12,000
jugglers. Below is my process broken into steps. There is no code here due to its
length, but check out the whole solution on the <a href="https://github.com/haikus-in-c/haikus-in-c/tree/master/2013.5/juggle_fest">github</a>. Also note that I
refer to Circuits and Jugglers with their first letters capitalized to signify that these
are classes.</p>

<ol>
<li><p>Read all Circuits and Jugglers into the program from an input file. This process can be
handled many different ways, but one important requirement is that we figure out the
total number of Jugglers and Circuits so we can determine the target number of Jugglers
that each Circuit should hold.</p></li>
<li><p>Assign all Jugglers to their first preference Circuits. I designed my Circuits so that they
contain two ArrayLists of Jugglers, one called jugglers, the other called overflow. Anytime
the jugglers ArrayList becomes full, any subsequent Juggler added to that Circuit is checked
against those already in jugglers. If it is better than none of them it is placed in overflow.
If the new Juggler <em>is</em> a better match for the Circuit than another Juggler, then the worst
match in jugglers is bumped down to overflow and the new Juggler is inserted in its sorted
position in jugglers.</p></li>
<li><p>Examine Circuits one-by-one and distribute the members of their overflow array (if there are
any) to the other Circuits. Repeat the following steps for each Circuit:</p>

<ol>
<li><p>Find the worst matched Juggler in the overflow array.</p></li>
<li><p>Check this Juggler against its next preference Circuit.</p>

<ol>
<li><p>If the Circuit is under capacity, add the Juggler to this Circuit immediately.</p></li>
<li><p>If the Circuit is at or over capacity, but the Juggler is a better match than one of the
Jugglers currently in the Circuit&rsquo;s jugglers ArrayList, insert it and kick the worst
performing Juggler down to overflow.</p></li>
<li><p>If the Circuit is at or over capacity and the Juggler is not a better match than one
of the Jugglers currently in jugglers, check against the next preference Circuit.</p></li>
<li><p>If this Juggler is not better than one of the Jugglers in its last preference Circuit,
check all Circuits for an under-full Circuit and add it there.</p></li>
</ol>
</li>
</ol>
</li>
<li><p>Sweep across all the Circuits, repeating steps 3-4 until they&rsquo;re all filled perfectly.</p></li>
</ol>

</p>

	<hr>

  
	<h1>
	  <a href="/posts/spotify-programming-challenge-funk">Let's Get Funky</a>
	</h1>
	
	<section class="byline">
	  by Ian Zapolsky, Apr 26, 2013
	</section>

	<p><p>Today we return to <a href="https://www.spotify.com/us/jobs/tech/">Spotify&rsquo;s hallowed puzzle page</a> for the second of the three puzzles
they offer there. This one, the middle brother in between <a href="http://haikus-in-c.com/posts/spotify-programming-challenge-reggae/">Reggae</a> and <a href="http://haikus-in-c.com">Heavy Metal</a>,
is called <em>Funk</em>.</p>

<p>Here&rsquo;s the problem: based on an input consisting of n songs on some album, where each song has its
own number of plays, we need to determine which song is the best (check the input format <a href="https://www.spotify.com/us/jobs/tech/zipfsong/">here</a>).
However, while intuition tells us to assume the most played song to be the best, we have to take
into account something called <a href="http://en.wikipedia.org/wiki/Zipf%27s_law"><em>Zipf&rsquo;s Law</em></a>, which states that the earlier songs on an album
(e.g. the first and second tracks) will be played more often than the later songs by nature of their position.</p>

<p>The law goes on to quantify this observation by saying that we should expect the nth song
of an album to be played roughly 1/n the number of times as the first.</p>

<p>I decided to approach this problem by designing a simple Song class to hold all the information
for a given song, including its plays, expected plays (based on Zipf&rsquo;s Law), and the ratio of
plays/expected plays. This ratio turns out to be the key to this problem because it measures the
popularity of songs not by play count (which for this problem is unhelpful), but by performance
of a song in relation to its expected play count by Zipf&rsquo;s Law. For example, if the first song on
an album has 100 plays, and the second has 51, then according to Zipf&rsquo;s Law the second is more
popular because it exceeds its expected number of plays of (&frac12;*100). Note that the first song
on an album will always have a plays/expected plays ratio of 1, because it is the first track&rsquo;s
plays by which we measure all the rest. So in this example, the first track has a ratio of 1 while
the second has a ratio of 1.02.</p>

<div class="highlight"><pre><code class="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Song</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Song</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="n">String</span> <span class="n">title</span><span class="o">;</span>
    <span class="kt">double</span> <span class="n">plays</span><span class="o">;</span>
    <span class="kt">double</span> <span class="n">expected_plays</span><span class="o">;</span>
    <span class="kt">double</span> <span class="n">ratio</span><span class="o">;</span> 

    <span class="kd">public</span> <span class="nf">Song</span><span class="o">(</span><span class="n">String</span> <span class="n">init_title</span><span class="o">,</span> <span class="kt">double</span> <span class="n">init_plays</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">init_title</span><span class="o">;</span>
        <span class="n">plays</span> <span class="o">=</span> <span class="n">init_plays</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setRatio</span><span class="o">(</span><span class="kt">double</span> <span class="n">track_one_plays</span><span class="o">,</span> <span class="kt">double</span> <span class="n">position</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">expected_plays</span> <span class="o">=</span> <span class="o">(</span><span class="n">track_one_plays</span><span class="o">/</span><span class="n">position</span><span class="o">);</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="o">(</span><span class="n">plays</span><span class="o">/</span><span class="n">expected_plays</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="n">Song</span> <span class="n">other</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getRatio</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="na">getRatio</span><span class="o">())</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">getRatio</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="na">getRatio</span><span class="o">())</span>
            <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">else</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getRatio</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">ratio</span><span class="o">;</span> <span class="o">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">title</span><span class="o">;</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>


<p>Now that we&rsquo;ve got this Song class, all we need to do is wrap up however many Songs we
have in an array or any other data structure that allows for quick iteration and sorting. I chose
array here just because of the relative simplicity of the sample inputs, but a linked list would
also be a totally valid choice.</p>

<p>Below is the main method, which reads input from the command line in the <a href="https://www.spotify.com/us/jobs/tech/zipfsong/">given format</a>,
constructs an array of Songs, and then iterates through the array, setting the expected plays
and ratios of each song based on the number of plays of the first song. Then we sort by ratio
and return the first m songs (as specified in the input) in descending order of popularity.</p>

<div class="highlight"><pre><code class="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

    <span class="n">Scanner</span> <span class="n">scan</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Scanner</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">in</span><span class="o">);</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Please enter your input:&quot;</span><span class="o">);</span>

    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">scan</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">scan</span><span class="o">.</span><span class="na">nextInt</span><span class="o">();</span>
    <span class="kt">double</span> <span class="n">track_one_plays</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">Song</span><span class="o">[]</span> <span class="n">album</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Song</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>

    <span class="cm">/* read input from stdin */</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="kt">double</span> <span class="n">plays</span> <span class="o">=</span> <span class="n">scan</span><span class="o">.</span><span class="na">nextDouble</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">track_one_plays</span> <span class="o">=</span> <span class="n">plays</span><span class="o">;</span>
        <span class="n">String</span> <span class="n">title</span> <span class="o">=</span> <span class="n">scan</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="n">album</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Song</span><span class="o">(</span><span class="n">title</span><span class="o">,</span> <span class="n">plays</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/*  set ratios for all songs in input */</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="n">album</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">].</span><span class="na">setRatio</span><span class="o">(</span><span class="n">track_one_plays</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>

    <span class="cm">/*  sort album by ratio using any sorting method */</span>
    <span class="n">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">album</span><span class="o">);</span>

    <span class="cm">/*  print result */</span>
    <span class="n">String</span> <span class="n">output</span> <span class="o">=</span> <span class="s">&quot;\n&quot;</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="n">output</span> <span class="o">+=</span> <span class="n">album</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="s">&quot;\n&quot;</span><span class="o">;</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">output</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>



</p>

	<hr>

  
	<h1>
	  <a href="/posts/spotify-programming-challenge-reggae">So This is What Reggae Feels Like</a>
	</h1>
	
	<section class="byline">
	  by Ian Zapolsky, Apr 12, 2013
	</section>

	<p><p>On <a href="https://www.spotify.com/us/jobs/tech/">Spotify&rsquo;s puzzle page</a>, they&rsquo;ve got three tech puzzles for potential hires
to play around with. This is the first of them, whose difficulty is rated <em>Reggae</em>.</p>

<p>Here&rsquo;s what we need to do: write a program to take some integer in decimal form
between 1 and 1,000,000,000 (inclusive), convert it to binary form, reverse that binary
string, and then convert the result back into decimal form. For example, on input 11,
we convert to binary number 1011, reverse to get 1101, then convert back to decimal form
to get 13 (11 > 1011 > 1101 > 13).</p>

<p>Let&rsquo;s continue with 11. 11 is 1011, or (1*2<sup>3</sup> + 0*2<sup>2</sup> + 1*2<sup>1</sup> + 1*2<sup>0</sup>), in binary.
Why is this?</p>

<p>If we divide 11 mod 2, we&rsquo;ll get a 1, telling us the remainder of
11/2 and consequently whether the 1s place of 11 in binary form is 1 or 0.</p>

<p>Now, let&rsquo;s divide 11/2, rounding down to the nearest integer, which makes 5.
This division allows us to raise our modulous divisor by a power of 2, or shift left
one place in binary. When we compute 5 mod 2 what we&rsquo;re really seeing is the
remainder of 11/4 expressed in terms of 2. Notice that if we didn&rsquo;t divide by
2 here and simply doubled the modulous divisor, we would get our remainder in 1s, which
in this case would be (11%4 = 3), a very unhelpful number in binary.</p>

<p>The central idea is to find the remainder of the number you&rsquo;re converting (in this case 11)/2<sup>n+1</sup>
in terms of 2<sup>n</sup>, which will always either be a 1 or a 0, in order to find the value of the nth
binary slot from the right.</p>

<div class="highlight"><pre><code class="bash">11%2 <span class="o">=</span> 1 --&gt; append to binary string: 1
11/2 <span class="o">=</span> 5
5%2 <span class="o">=</span> 1  --&gt; append to binary string: 11
5/2 <span class="o">=</span> 2
2%2 <span class="o">=</span> 0  --&gt; append to binary string: 011
2/2 <span class="o">=</span> 1
1%2 <span class="o">=</span> 1  --&gt; append to binary string: 1011
1/2 <span class="o">=</span> 0  --&gt; stop because we reach 0
</code></pre></div>


<p>Notice that the example above appends new 1s and 0s <em>to the left</em>. This means that if we were
to append to the right in a method, as I do below, it would yield an already-reversed binary string,
thus killing two birds with one piece of code!</p>

<div class="highlight"><pre><code class="java"><span class="n">String</span> <span class="nf">convertDecimalToReversedBinary</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="s">&quot;&quot;</span><span class="o">+(</span><span class="n">value</span><span class="o">%</span><span class="mi">2</span><span class="o">);</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">/</span><span class="mi">2</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>


<p>Now, all we need is a method to convert a binary string back into an integer. This isn&rsquo;t
hard, as we already know how binary strings are put together. My method works backwards
from the end of the String, adding increasing powers of 2 to a final result.</p>

<div class="highlight"><pre><code class="java"><span class="kt">int</span> <span class="nf">convertBinaryToDecimal</span><span class="o">(</span><span class="n">String</span> <span class="n">binary</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="o">(</span><span class="n">binary</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">binary</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">&#39;1&#39;</span><span class="o">)</span>
            <span class="n">value</span> <span class="o">+=</span> <span class="n">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">count</span><span class="o">);</span>
        <span class="n">count</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div>


<p>And that&rsquo;s it! We solved the first Spotify programming challenge.</p>
</p>

	<hr>

  
	<h1>
	  <a href="/posts/welcome">Welcome</a>
	</h1>
	
	<section class="byline">
	  by Ian Zapolsky, Apr  5, 2013
	</section>

	<p><p>Welcome to <a href="https://haikus-in-c.github.io">Haikus in C</a>, the programming blog of Ian and Ruchir, two
CS students at Columbia.</p>

<p>Stay tuned for our migration here from <a href="https://haikusinc.tumblr.com">tumblr</a>, and some new posts too!</p>
</p>

	<hr>

  
</section>


</body>

</html>
