<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <meta charset="utf-8">
  <title>
    
      Home &ndash;
    
    Haikus in C
  </title>

  <meta name="author" content="Haikus in C" />
  <meta name="description" content="a place where two columbia cs students share code and talk about their projects" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <link rel="alternate" type="application/rss+xml" href="/atom.xml" />

  <link rel="stylesheet" href="/css/fontawesome.min.css" type="text/css" media="screen, projection" />
  <link rel="stylesheet" href="/css/base.css" type="text/css" media="screen, projection" />
  <link rel="stylesheet" href="/css/pygments.css" type="text/css" />
  <link media="only screen and (max-device-width: 480px)" href="/css/mobile.css" type="text/css" rel="stylesheet" />
  <link media="only screen and (device-width: 768px)" href="/css/mobile.css" type="text/css" rel="stylesheet" />
  <link href='http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz' rel='stylesheet' type='text/css'>
  <link rel="apple-touch-icon" href="/apple-touch-icon.png" />

  <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
  <script type="text/javascript" src="/js/application.js"></script>
</head>

<body>
  <section class="header">
	<h1>
	  <a href="/">Haikus in C</a>
	</h1>
  </section>

  <section class="sidebar">

    <section class="meta">
      <a href="https://github.com/haikus-in-c" target="_blank"><i class="icon icon-github"></i></a>
    </section>

    <section class="sections">
      <ul>
		<li><a href="/">home</a><li>
        <li><a href="/about.html">about</a></li>
        <li><a href="/posts.html">posts</a></li>
      </ul>
    </section>

	<section class="shoutout">
	  <p>made with help from <a href="https://github.com/mojombo/jekyll">jekyll</a> and an adapted theme from
		<a href="http://zachholman.com/">zach holman</a>.</p>
	</section>

  </section>

  <section class="content">
  
	<h1>
	  <a href="/posts/task-optimization">Dictionary Optimization with the Google Chrome Omnibox</a>
	</h1>
	
	<section class="byline">
	  by Ian Zapolsky, November 13, 2013
	</section>

    <p><p>Here&rsquo;s a fairly common scenario I have been running into this semester: I&rsquo;m
reading something in Spanish at the computer, I come across a word I don&rsquo;t know.
I look at it, contemplate looking it up, and continue reading. It&rsquo;s borderline
terrifying that I&rsquo;m so spoiled by the speed of modern technology that I consider
the time it takes to open a new browser tab, google my favorite Spanish-English
dictionary site, and enter the word I&rsquo;m looking for to be prohibitive, but I do.</p>

<p>But perhaps this superhuman level of laziness is what will ultimately drive the
next wave of technological advances necessary to achieve the ultimate informational nirvana
toward which the internet and modern search engine power is moving, a world
in which you can instantly recieve information about things you look at in real
time.</p>

<p>I recently decided to take my own small step toward this goal by writing two
simple but effective Google Chrome extensions to help optimize the process
of translating words and phrases between Spanish and English, and conjugating
Spanish and English verbs.</p>
</p>
    <p style="text-align:center;"><a href="/posts/task-optimization">read more...</a></p>

	<hr>

  
	<h1>
	  <a href="/posts/argentinian-drinking-game">When an Argentinian Drinking Game Meets Computer Science</a>
	</h1>
	
	<section class="byline">
	  by Ian Zapolsky, September  1, 2013
	</section>

    <p><p>I love drinking games.</p>

<p>They&rsquo;re social, they&rsquo;re entertaining, but most importantly they have the unique
quality of making losing fun. Perhaps the most famous drinking game in the
world is beer pong, a game of which I am a strong proponent. However, beer pong
offers little in the way of statistics or information a computer scientist could
analyze to gain the upper hand: it all comes down to whether or not you can make
the shot.</p>

<p>There are other, more cerebral types of drinking games of course, that <em>do</em> offer
opportunties for <strike>cheating</strike> observation and analysis. Today I
would like the share one with you that I learned this past weekend in
Buenos Aires. As far as I can tell it does not have an official name, and there
very well may be a North American/English speaking version already being played.
It&rsquo;s great fun but, as we&rsquo;ll see in this post, it is completely unfair.</p>
</p>
    <p style="text-align:center;"><a href="/posts/argentinian-drinking-game">read more...</a></p>

	<hr>

  
	<h1>
	  <a href="/posts/cats-vs-dogs">Cats vs Dogs</a>
	</h1>
	
	<section class="byline">
	  by Ruchir Khaitan, August 19, 2013
	</section>

    <p><p>The final <a href="https://www.spotify.com/us/jobs/tech/">Spotify</a> puzzle is a heavy metal showdown that brings together two beloved pets and a wide variety of computer science topics. Unfortunately, this problem took a lot longer than it should have, because I was stubborn, and refused to let go of preconceived ideas of how to solve it even when I could clearly see that my approach was incorrect. Basically, I was looking at it all wrong. The general premise, explained in more detail <a href="https://www.spotify.com/us/jobs/tech/catvsdog/">here</a>, is that each week in a TV game show for cats and dogs, a pet is removed based on a vote. Each person watching votes for one pet that they want to keep on the show, and one that they want to remove, and people cannot choose members of the same species for both. Most importantly, the producers will remove pets in an effort to maximize viewership, and so the question is: what is the maximum number of voters that can be satisfied, meaning that both their choices have been carried out, given a set of votes (and assuming that those votes dont change over time).</p>

<p>My initial idea was simplistic and based on a flawed assumption. I inferred, purely on intuition, that the removed pets would be the ones with the least positive votes, and the most negative votes and created a data structure to represent pets and voters characterizing each pet by fitness which was the number of upvotes &ndash; the number of downvotes. I like to call this the &ldquo;Reddit&rdquo; solution.</p>

<div class="highlight"><pre><code class="c">    <span class="k">struct</span> <span class="n">pet</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">fitness</span><span class="p">;</span> <span class="c1">//running tally of upvotes - downvotes</span>
            <span class="kt">int</span> <span class="n">contending</span><span class="p">;</span> <span class="c1">//whether this pet is still in</span>
    <span class="p">};</span>
    <span class="k">struct</span> <span class="n">voter</span> <span class="p">{</span>
            <span class="k">struct</span> <span class="n">pet</span><span class="o">*</span> <span class="n">keep</span><span class="p">;</span>
            <span class="k">struct</span> <span class="n">pet</span><span class="o">*</span> <span class="n">reject</span><span class="p">;</span>   
    <span class="p">};</span> 
</code></pre></div>


<p>Then I simulated the game by removing the least fit pets and keeping track of the number of people satisfied at each step, and then returning the maximum number.</p>

<div class="highlight"><pre><code class="c">    <span class="k">struct</span> <span class="n">pet</span><span class="o">*</span> <span class="nf">find_min</span><span class="p">(</span><span class="k">struct</span> <span class="n">pet</span><span class="o">*</span> <span class="n">c_addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span><span class="k">struct</span> <span class="n">pet</span><span class="o">*</span> <span class="n">d_addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//returns weakest pet out of array of c cats and d dogs in O(n)</span>
            <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span> <span class="c1">//random large number </span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">struct</span> <span class="n">pet</span><span class="o">*</span> <span class="n">min_addr</span><span class="p">,</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">c</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">c_addr</span><span class="o">+</span> <span class="n">i</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">curr</span> <span class="o">-&gt;</span><span class="n">fitness</span> <span class="o">&lt;</span> <span class="n">min</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">contending</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
                    <span class="n">min</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">fitness</span><span class="p">;</span>
                    <span class="n">min_addr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="p">}</span>    
            <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">d</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">curr</span> <span class="o">=</span> <span class="n">d_addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
                <span class="k">if</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">fitness</span><span class="o">&lt;</span> <span class="n">min</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">contending</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">min</span> <span class="o">=</span> <span class="n">curr</span> <span class="o">-&gt;</span><span class="n">fitness</span><span class="p">;</span>
                        <span class="n">min_addr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">min_addr</span><span class="o">-&gt;</span><span class="n">contending</span> <span class="o">=</span>  <span class="mi">0</span><span class="p">;</span>   
        <span class="k">return</span> <span class="n">min_addr</span><span class="p">;</span>   
    <span class="p">}</span> 
    <span class="kt">int</span> <span class="nf">sim_game</span><span class="p">(</span><span class="k">struct</span> <span class="n">voter</span><span class="o">*</span> <span class="n">v_addr</span><span class="p">,</span><span class="kt">int</span> <span class="n">v</span><span class="p">,</span><span class="k">struct</span> <span class="n">pet</span><span class="o">*</span><span class="n">c_addr</span><span class="p">,</span><span class="kt">int</span> <span class="n">c</span><span class="p">,</span><span class="k">struct</span> <span class="n">pet</span><span class="o">*</span><span class="n">d_addr</span><span class="p">,</span><span class="kt">int</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">num_satisfied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
            <span class="kt">int</span> <span class="n">max_satisfied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">pets_remain</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
            <span class="k">struct</span> <span class="n">pet</span><span class="o">*</span> <span class="n">weakest</span><span class="p">;</span>
            <span class="k">while</span><span class="p">(</span><span class="n">pets_remain</span><span class="p">){</span>
                <span class="n">weakest</span> <span class="o">=</span> <span class="n">find_min</span><span class="p">(</span><span class="n">c_addr</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d_addr</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span> 
            <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">v</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">v_addr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">keep</span><span class="o">-&gt;</span><span class="n">contending</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">v_addr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">reject</span><span class="o">-&gt;</span><span class="n">contending</span><span class="p">))</span>
                    <span class="n">num_satisfied</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span><span class="p">(</span><span class="n">num_satisfied</span><span class="o">&gt;</span> <span class="n">max_satisfied</span><span class="p">)</span> 
                    <span class="n">max_satisfied</span> <span class="o">=</span> <span class="n">num_satisfied</span><span class="p">;</span>

            <span class="n">num_satisfied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">pets_remain</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">max_satisfied</span><span class="p">;</span>   
    <span class="p">}</span> 
</code></pre></div>


<p>Unfortunately, this approach didnt work and I was at a loss to explain why since it seemed to work for the two test inputs given, and I couldnt engineer a new test case that would break my algorithm.</p>
</p>
    <p style="text-align:center;"><a href="/posts/cats-vs-dogs">read more...</a></p>

	<hr>

  

  <div style="text-align:center;" class="pagination">
    
      <span class="previous">previous</span>
    
    <span class="page_number ">| page 1 of 4 |</span>
    
      <a href="/page2" class="next">next &raquo;</a>
    
  </div>

</section>


</body>

</html>
